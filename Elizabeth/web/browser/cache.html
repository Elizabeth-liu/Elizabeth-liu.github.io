<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从输入URL到页面加载的过程？ | vue</title>
    <meta name="description" content="Vue-powered Static Site Generator">
    <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.0f4aee89.css" as="style"><link rel="preload" href="/assets/js/app.195883db.js" as="script"><link rel="preload" href="/assets/js/27.4add591c.js" as="script"><link rel="prefetch" href="/assets/js/2.e7890f8a.js"><link rel="prefetch" href="/assets/js/3.ab963558.js"><link rel="prefetch" href="/assets/js/4.3e7f7d5d.js"><link rel="prefetch" href="/assets/js/5.61cd9603.js"><link rel="prefetch" href="/assets/js/6.451039b8.js"><link rel="prefetch" href="/assets/js/7.c0439f0b.js"><link rel="prefetch" href="/assets/js/8.68bc9b93.js"><link rel="prefetch" href="/assets/js/9.a56af132.js"><link rel="prefetch" href="/assets/js/10.5fa43a78.js"><link rel="prefetch" href="/assets/js/11.10c3f9b4.js"><link rel="prefetch" href="/assets/js/12.6792c220.js"><link rel="prefetch" href="/assets/js/13.f98e24b0.js"><link rel="prefetch" href="/assets/js/14.8dae6801.js"><link rel="prefetch" href="/assets/js/15.6c7e6508.js"><link rel="prefetch" href="/assets/js/16.cb6466a7.js"><link rel="prefetch" href="/assets/js/17.8743a056.js"><link rel="prefetch" href="/assets/js/18.21cf47e5.js"><link rel="prefetch" href="/assets/js/19.b82c7bba.js"><link rel="prefetch" href="/assets/js/20.5c0486a0.js"><link rel="prefetch" href="/assets/js/21.4bfec1b4.js"><link rel="prefetch" href="/assets/js/22.4528728e.js"><link rel="prefetch" href="/assets/js/23.c5f11a56.js"><link rel="prefetch" href="/assets/js/24.16abf977.js"><link rel="prefetch" href="/assets/js/25.34ad2c9c.js"><link rel="prefetch" href="/assets/js/26.2d4eb647.js"><link rel="prefetch" href="/assets/js/28.f38e45b4.js"><link rel="prefetch" href="/assets/js/29.32d0acf2.js"><link rel="prefetch" href="/assets/js/30.a5927114.js"><link rel="prefetch" href="/assets/js/31.662b15c6.js"><link rel="prefetch" href="/assets/js/32.d7e1de5f.js"><link rel="prefetch" href="/assets/js/33.8372b9a9.js"><link rel="prefetch" href="/assets/js/34.d04c5ba0.js"><link rel="prefetch" href="/assets/js/35.a257471e.js"><link rel="prefetch" href="/assets/js/36.f4c225a5.js"><link rel="prefetch" href="/assets/js/37.5614038d.js"><link rel="prefetch" href="/assets/js/38.3bc79a58.js"><link rel="prefetch" href="/assets/js/39.e42490b0.js"><link rel="prefetch" href="/assets/js/40.5f3bfe75.js"><link rel="prefetch" href="/assets/js/41.b056b7ac.js"><link rel="prefetch" href="/assets/js/42.65c2409e.js"><link rel="prefetch" href="/assets/js/43.fe8bb8d4.js"><link rel="prefetch" href="/assets/js/44.30671b3f.js"><link rel="prefetch" href="/assets/js/45.630d1da7.js"><link rel="prefetch" href="/assets/js/46.2ddb121b.js"><link rel="prefetch" href="/assets/js/47.22b577b6.js"><link rel="prefetch" href="/assets/js/48.8375422b.js"><link rel="prefetch" href="/assets/js/49.a18d769c.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.708c3ca7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0f4aee89.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">vue</span></a> <div class="links" style="max-width:nullpx;"><form id="search-form" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/web/js/" class="nav-link">js</a></li><li class="dropdown-item"><!----> <a href="/web/browser/" class="nav-link router-link-active">browser</a></li><li class="dropdown-item"><!----> <a href="/web/css/" class="nav-link">css</a></li><li class="dropdown-item"><!----> <a href="/web/react/" class="nav-link">react</a></li><li class="dropdown-item"><!----> <a href="/web/vue/" class="nav-link">vue</a></li><li class="dropdown-item"><!----> <a href="/web/webpack/" class="nav-link">webpack</a></li><li class="dropdown-item"><!----> <a href="/web/babel/" class="nav-link">babel</a></li><li class="dropdown-item"><!----> <a href="/web/performance/" class="nav-link">performance</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backend/nodejs/" class="nav-link">nodejs</a></li><li class="dropdown-item"><!----> <a href="/backend/others/" class="nav-link">其他</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">计算机</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/computer/algorithm/" class="nav-link">算法与数据结构</a></li><li class="dropdown-item"><!----> <a href="/computer/http/" class="nav-link">http</a></li><li class="dropdown-item"><!----> <a href="/computer/patterns/" class="nav-link">设计模式</a></li></ul></div></div></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><ul class="sidebar-links"><li><a href="/web/browser/" class="sidebar-link">浏览器</a></li><li><a href="/web/browser/cache.html" class="active sidebar-link">从输入URL到页面加载的过程？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/browser/cache.html#浏览器接收url到开启网络请求线程" class="sidebar-link">浏览器接收url到开启网络请求线程</a></li><li class="sidebar-sub-header"><a href="/web/browser/cache.html#开启网络线程到发出一个完整的http请求" class="sidebar-link">开启网络线程到发出一个完整的http请求</a></li><li class="sidebar-sub-header"><a href="/web/browser/cache.html#从服务器接收到请求到对应后台接收到请求" class="sidebar-link">从服务器接收到请求到对应后台接收到请求</a></li><li class="sidebar-sub-header"><a href="/web/browser/cache.html#后台和前台的http交互" class="sidebar-link">后台和前台的http交互</a></li><li class="sidebar-sub-header"><a href="/web/browser/cache.html#缓存问题" class="sidebar-link">缓存问题</a></li><li class="sidebar-sub-header"><a href="/web/browser/cache.html#解析页面流程" class="sidebar-link">解析页面流程</a></li><li class="sidebar-sub-header"><a href="/web/browser/cache.html#参照" class="sidebar-link">参照</a></li></ul></li><li><a href="/web/browser/router.html" class="sidebar-link">路由</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="从输入url到页面加载的过程？"><a href="#从输入url到页面加载的过程？" aria-hidden="true" class="header-anchor">#</a> 从输入URL到页面加载的过程？</h1> <h2 id="浏览器接收url到开启网络请求线程"><a href="#浏览器接收url到开启网络请求线程" aria-hidden="true" class="header-anchor">#</a> 浏览器接收url到开启网络请求线程</h2> <h3 id="多进程的浏览器"><a href="#多进程的浏览器" aria-hidden="true" class="header-anchor">#</a> 多进程的浏览器</h3> <p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）</p> <p>进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p> <p>Browser进程：浏览器的主进程（负责协调、主控），只有一个
第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
GPU进程：最多一个，用于3D绘制
浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</p> <h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" aria-hidden="true" class="header-anchor">#</a> 多线程的浏览器内核</h3> <p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p> <p>GUI线程
JS引擎线程
事件触发线程
定时器线程
网络请求线程</p> <h3 id="解析url"><a href="#解析url" aria-hidden="true" class="header-anchor">#</a> 解析URL</h3> <p>输入URL后，会进行解析（URL的本质就是统一资源定位符）</p> <p>URL一般包括几大部分：</p> <p>protocol，协议头，譬如有http，ftp等
host，主机域名或IP地址
port，端口号
path，目录路径
query，即查询参数
fragment，即#后的hash值，一般用来定位到某个位置
网络请求都是单独的线程
每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p> <p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p> <h2 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" aria-hidden="true" class="header-anchor">#</a> 开启网络线程到发出一个完整的http请求</h2> <h3 id="dns查询得到ip"><a href="#dns查询得到ip" aria-hidden="true" class="header-anchor">#</a> DNS查询得到IP</h3> <p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p> <p>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host
如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP
注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</p> <p>而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化</p> <h3 id="tcp-ip请求"><a href="#tcp-ip请求" aria-hidden="true" class="header-anchor">#</a> tcp/ip请求</h3> <p>http的本质就是tcp/ip请求</p> <p>需要了解3次握手规则建立连接以及断开连接时的四次挥手</p> <p>tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输</p> <h4 id="五层因特网协议栈"><a href="#五层因特网协议栈" aria-hidden="true" class="header-anchor">#</a> 五层因特网协议栈</h4> <p>1.应用层(dns,http) DNS解析成IP并发送http请求</p> <p>2.传输层(tcp,udp) 建立tcp连接（三次握手）</p> <p>3.网络层(IP,ARP) IP寻址</p> <p>4.数据链路层(PPP) 封装成帧</p> <p>5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）
OSI七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p> <p>表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</p> <p>会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</p> <h2 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" aria-hidden="true" class="header-anchor">#</a> 从服务器接收到请求到对应后台接收到请求</h2> <h3 id="负载均衡"><a href="#负载均衡" aria-hidden="true" class="header-anchor">#</a> 负载均衡</h3> <p>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</p> <h3 id="后台的处理"><a href="#后台的处理" aria-hidden="true" class="header-anchor">#</a> 后台的处理</h3> <p>一般后台都是部署到容器中的，所以一般为：</p> <p>先是容器接受到请求（如tomcat容器）
然后对应容器中的后台程序接收到请求（如java程序）
然后就是后台会有自己的统一处理，处理完后响应响应结果</p> <h2 id="后台和前台的http交互"><a href="#后台和前台的http交互" aria-hidden="true" class="header-anchor">#</a> 后台和前台的http交互</h2> <h3 id="状态码"><a href="#状态码" aria-hidden="true" class="header-anchor">#</a> 状态码</h3> <p>200——表明该请求被成功地完成，所请求的资源发送回客户端
304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
400——客户端请求有错（譬如可以是安全模块拦截）
401——请求未经授权
403——禁止访问（譬如可以是未登录时禁止）
404——资源未找到
500——服务器内部错误
503——服务不可用
...
再列举下大致不同范围状态的意义</p> <p>1xx——指示信息，表示请求已接收，继续处理
2xx——成功，表示请求已被成功接收、理解、接受
3xx——重定向，要完成请求必须进行更进一步的操作
4xx——客户端错误，请求有语法错误或请求无法实现
5xx——服务器端错误，服务器未能实现合法的请求</p> <h3 id="请求头"><a href="#请求头" aria-hidden="true" class="header-anchor">#</a> 请求头</h3> <p><img src="https://pic2.zhimg.com/80/v2-626730a88ec4c6a66738d6fba41a09b1_hd.jpg" alt="请求头"></p> <h3 id="cookie"><a href="#cookie" aria-hidden="true" class="header-anchor">#</a> cookie</h3> <p><img src="https://pic4.zhimg.com/80/v2-e88c18ad8f8469688596c86504267c4b_hd.jpg" alt="cookie"></p> <h3 id="长连接与短连接"><a href="#长连接与短连接" aria-hidden="true" class="header-anchor">#</a> 长连接与短连接</h3> <p>首先看tcp/ip层面的定义：</p> <p>长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）
短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接
然后在http层面：</p> <p>http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接
http1.1起，默认使用长连接，使用长连接会有这一行Connection: keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接
注意： keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</p> <h3 id="http2-0"><a href="#http2-0" aria-hidden="true" class="header-anchor">#</a> http2.0</h3> <p>多路复用（即一个tcp/ip连接可以请求多个资源）
首部压缩（http头部压缩，减少体积）
二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</p> <h3 id="https"><a href="#https" aria-hidden="true" class="header-anchor">#</a> https</h3> <p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。</p> <p>简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</p> <p>一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）</p> <p>一般来说，主要关注的就是SSL/TLS的握手流程，如下（简述）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> 浏览器请求建立<span class="token constant">SSL</span>链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如<span class="token constant">RSA</span>加密，此时是明文传输。

<span class="token number">2.</span> 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器
（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）

<span class="token number">3.</span> 浏览器收到服务端的证书后

    <span class="token operator">-</span> 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示

    <span class="token operator">-</span> 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密<span class="token template-string"><span class="token string">`Premaster secret`</span></span>，发送给服务器。

    <span class="token operator">-</span> 利用Client random、Server random和Premaster secret通过一定的算法生成<span class="token constant">HTTP</span>链接数据传输的对称加密key<span class="token operator">-</span><span class="token template-string"><span class="token string">`session key`</span></span>

    <span class="token operator">-</span> 使用约定好的<span class="token constant">HASH</span>算法计算握手消息，并使用生成的<span class="token template-string"><span class="token string">`session key`</span></span>对消息进行加密，最后将之前生成的所有信息发送给服务端。

<span class="token number">4.</span> 服务端收到浏览器的回复

    <span class="token operator">-</span> 利用已知的加解密方式与自己的私钥进行解密，获取<span class="token template-string"><span class="token string">`Premaster secret`</span></span>

    <span class="token operator">-</span> 和浏览器相同规则生成<span class="token template-string"><span class="token string">`session key`</span></span>

    <span class="token operator">-</span> 使用<span class="token template-string"><span class="token string">`session key`</span></span>解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致

    <span class="token operator">-</span> 使用<span class="token template-string"><span class="token string">`session key`</span></span>加密一段握手消息，发送给浏览器

<span class="token number">5.</span> 浏览器解密并计算握手消息的<span class="token constant">HASH</span>，如果与服务端发来的<span class="token constant">HASH</span>一致，此时握手过程结束，
之后所有的https通信数据将由之前
</code></pre></div><h2 id="缓存问题"><a href="#缓存问题" aria-hidden="true" class="header-anchor">#</a> 缓存问题</h2> <h3 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" aria-hidden="true" class="header-anchor">#</a> 强缓存与弱缓存</h3> <p>缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）</p> <p>区别简述如下：</p> <p>强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求
协商缓存（304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存
对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效</p> <p>但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）</p> <h3 id="缓存头部简述"><a href="#缓存头部简述" aria-hidden="true" class="header-anchor">#</a> 缓存头部简述</h3> <p>属于强缓存控制的：</p> <p>（http1.1）Cache-Control/Max-Age
（http1.0）Pragma/Expires
注意：Max-Age不是一个头部，它是Cache-Control头部的值</p> <p>属于协商缓存控制的：</p> <p>（http1.1）If-None-Match/E-tag
（http1.0）If-Modified-Since/Last-Modified
可以看到，上述有提到http1.1和http1.0，这些不同的头部是属于不同http时期的</p> <p>再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-Pragma</p> <h3 id="头部的区别"><a href="#头部的区别" aria-hidden="true" class="header-anchor">#</a> 头部的区别</h3> <p>首先明确，http的发展是从http1.0到http1.1</p> <p>而在http1.1中，出了一些新内容，弥补了http1.0的不足。</p> <p>http1.0中的缓存控制：</p> <p>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）
Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如Expires：Fri, 30 Oct 1998 14:19:41
If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到1s以内
http1.1中的缓存控制：</p> <p>Cache-Control：缓存控制头部，有no-cache、max-age等多种取值
Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如Cache-Control: max-age=3600，而且它值得是绝对时间，由浏览器自己计算
If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag，同样，发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。
Max-Age相比Expires？</p> <p>Expires使用的是服务器端的时间</p> <p>但是有时候会有这样一种情况-客户端时间和服务端不同步</p> <p>那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期</p> <p>所以一般http1.1后不推荐使用Expires</p> <p>而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题</p> <p>因此推荐使用Max-Age。</p> <p>注意，如果同时启用了Cache-Control与Expires，Cache-Control优先级高。</p> <p>E-tag相比Last-Modified？</p> <p>Last-Modified：</p> <p>表明服务端的文件最后何时改变的
它有一个缺陷就是只能精确到1s，
然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效
而E-tag：</p> <p>是一种指纹机制，代表文件相关指纹
只有文件变才会变，也只要文件变就会变，
也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了
如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag</p> <p>各大缓存头部的整体关系如下图
<img src="https://pic3.zhimg.com/80/v2-c7562f5345c992e993623e378e685bde_hd.jpg" alt="缓存"></p> <h2 id="解析页面流程"><a href="#解析页面流程" aria-hidden="true" class="header-anchor">#</a> 解析页面流程</h2> <h3 id="流程简述"><a href="#流程简述" aria-hidden="true" class="header-anchor">#</a> 流程简述</h3> <p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1.</span> 解析<span class="token constant">HTML</span>，构建<span class="token constant">DOM</span>树

<span class="token number">2.</span> 解析<span class="token constant">CSS</span>，生成<span class="token constant">CSS</span>规则树

<span class="token number">3.</span> 合并<span class="token constant">DOM</span>树和<span class="token constant">CSS</span>规则，生成render树

<span class="token number">4.</span> 布局render树（Layout<span class="token operator">/</span>reflow），负责各元素尺寸、位置的计算

<span class="token number">5.</span> 绘制render树（paint），绘制页面像素信息

<span class="token number">6.</span> 浏览器会将各层的信息发送给<span class="token constant">GPU</span>，<span class="token constant">GPU</span>会将各层合成（composite），显示在屏幕上
</code></pre></div><p><img src="https://pic3.zhimg.com/80/v2-2a7db99cc39992e3c605926b37939042_hd.jpg" alt="流程"></p> <p>解析HTML到构建出DOM的过程可以简述如下：</p> <p>Bytes → characters → tokens → nodes → DOM</p> <p>资源外链的下载
上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p> <p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p> <p>CSS样式资源
JS脚本资源
img图片类资源
遇到外链时的处理</p> <p>当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）</p> <p>遇到CSS样式资源</p> <p>CSS资源的处理有几个特点：</p> <p>CSS下载时异步，不会阻塞浏览器构建DOM树
但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）
有例外，media query声明的CSS是不会阻塞渲染的
遇到JS脚本资源</p> <p>JS脚本资源的处理有几个特点：</p> <p>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML
浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已
defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行
注意，defer和async是有区别的： defer是延迟执行，而async是异步执行。</p> <p>简单的说（不展开）：</p> <p>async是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前或后
defer是延迟执行，在浏览器看起来的效果像是将脚本放在了body后面一样（虽然按规范应该是在DOMContentLoaded事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）
遇到img图片类资源</p> <p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p> <p>loaded和domcontentloaded
简单的对比：</p> <p>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)
load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</p> <h2 id="参照"><a href="#参照" aria-hidden="true" class="header-anchor">#</a> 参照</h2> <p>https://zhuanlan.zhihu.com/p/34453198</p></div> <div class="page-edit"><div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/15/2020, 6:34:56 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/web/browser/" class="prev router-link-active">
          浏览器
        </a></span> <span class="next"><a href="/web/browser/router.html">
          路由
        </a>
        →
      </span></p></div> <div class="bsa-cpc-wrapper"><div class="bsa-cpc"></div></div></div> <!----></div></div>
    <script src="/assets/js/27.4add591c.js" defer></script><script src="/assets/js/app.195883db.js" defer></script>
  </body>
</html>
